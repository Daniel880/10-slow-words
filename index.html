<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>10 Slow Words</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #fff;
      color: #000;
    }

    .dark {
      background-color: #121212;
      color: #e0e0e0;
    }

    .word-list {
      margin-bottom: 20px;
      font-size: 3em;
    }

    .word-list span {
      margin-right: 5px;
    }

    .current {
      text-decoration: underline;
    }

    .correct {
      color: green;
    }

    .incorrect {
      color: red;
    }

    input {
      width: 100%;
      font-size: 3em;
      padding: 5px;
    }

    .results,
    .stats {
      margin-top: 20px;
    }

    .highlight {
      font-weight: bold;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f0f0f0;
    }

    .dark th,
    .dark td {
      background-color: #1e1e1e;
      color: #fff;
      border-color: #333;
    }

    .dark th {
      background-color: #2e2e2e;
    }

    .dark input {
      background-color: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
    }

    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
    }

    .global-stats {
      display: flex;
      gap: 2em;
      font-size: 1.2em;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <h1>10 Slow Words</h1>
  <div class="word-list" id="wordList"></div>
  <input type="text" id="input" placeholder="Start typing..." autofocus />
  <div class="results" id="results"></div>
  <div class="stats" id="stats"></div>
  <canvas id="wpmChart" width="800" height="400"></canvas>
  <canvas id="wordsScatterChart" width="800" height="400"></canvas>
  <button onclick="resetStats()">Reset All Stats</button>
  <button onclick="toggleTheme()">Toggle Dark Mode</button>
  <button onclick="refreshCharts()">Refresh Charts</button>

  <script>
    let english1k = [];
    let testWords = [];
    let startTime = null;
    let testStartTime;
    let currentIndex = 0;
    let wordStats = {};
    let history = [];
    let slowestWords = [];
    let chart;
    let scatterChart; // Dodaj tę zmienną do śledzenia wykresu rozproszenia
    let slow10WPMHistory = [];
    let testWPMHistory = [];

    // Add these variables at the top to track sorting
    let currentSortColumn = 'avg5'; // Default sort by Avg Last 5
    let currentSortDirection = 'asc'; // Default ascending order

    // Add a function to update the results display that can be called anytime
    function updateResultsDisplay() {
      // Get the average WPM of the 10 slowest words
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
        return { word, avg5 };
      });

      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? (slow10.map(e => e.avg5).reduce((a, b) => a + b, 0) / slow10.length) : 0;

      // Calculate average of all overall test WPMs
      const avgTestWPM = testWPMHistory.length
        ? (testWPMHistory.reduce((a, b) => a + b, 0) / testWPMHistory.length).toFixed(1)
        : "-";

      // Get the last test WPM
      const lastTestWPM = testWPMHistory.length ? testWPMHistory[testWPMHistory.length - 1].toFixed(1) : "-";

      // Display the metrics
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = `
        <h2>Statistics</h2>
        <div class="global-stats">
          <div><strong>Last Test WPM:</strong> ${lastTestWPM}</div>
          <div><strong>Average WPM:</strong> ${avgTestWPM}</div>
          <div><strong>Slowest 10 Words WPM:</strong> ${avgOf10.toFixed(1)}</div>
        </div>
      `;
    }

    // Fix combined functions to ensure test reloads properly
    document.getElementById("input").addEventListener("input", function (e) {
      const typed = this.value.trim();
      const expected = testWords[currentIndex];

      if (!testStartTime && typed.length > 0) {
        testStartTime = performance.now();
        startTime = testStartTime;
      }

      const currentWordEl = document.querySelector(".current");
      if (expected && expected.startsWith(typed)) {
        currentWordEl?.classList.remove("incorrect");

        // Check for last word completion when the typed text matches exactly
        if (currentIndex === testWords.length - 1 && typed === expected) {
          // Store the last word before incrementing currentIndex
          const lastWord = expected;
          const inputEl = this; // Save reference to input element

          // First make the word green by updating currentIndex
          currentIndex++;
          renderWords(); // Update UI to show the last word as green

          // Handle completion immediately without delay
          // Force completion of the last word using the stored lastWord variable
          const now = performance.now();
          const duration = (now - startTime) / 1000 / 60;
          const wpm = 1 / duration;

          // Update word stats for the last word
          if (!wordStats[lastWord]) {
            wordStats[lastWord] = {
              avg: wpm,
              last: wpm,
              last5: [wpm],
              count: 1
            };
          } else {
            wordStats[lastWord].avg = (wordStats[lastWord].avg * 0.8 + wpm * 0.2);
            wordStats[lastWord].last = wpm;
            wordStats[lastWord].last5 = (wordStats[lastWord].last5 || []).slice(-4).concat(wpm);
            wordStats[lastWord].count = (wordStats[lastWord].count || 0) + 1;
          }

          // Calculate overall stats
          const totalCharCount = testWords.reduce((sum, word) => sum + word.length, 0);
          const spacesCount = testWords.length - 1;
          const totalTimeMin = (performance.now() - testStartTime) / 1000 / 60;
          const overallWPM = ((totalCharCount + spacesCount) / 5) / totalTimeMin;
          testWPMHistory.push(parseFloat(overallWPM.toFixed(1)));

          // Update slow10WPMHistory
          const entries = Object.entries(wordStats).map(([word, data]) => {
            const last5 = data.last5 || [];
            const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
            return { word, avg5 };
          });

          const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
          const avgOf10 = slow10.length ? (slow10.map(e => e.avg5).reduce((a, b) => a + b, 0) / slow10.length) : 0;
          if (!isNaN(avgOf10)) {
            slow10WPMHistory.push(parseFloat(avgOf10.toFixed(1)));
          }

          // Save and update UI
          saveStatsToStorage();

          // Clear input field immediately
          inputEl.value = "";

          try {
            // Update results and stats before starting new test
            updateResultsDisplay();
            renderStats();

            // Separate try/catch for charts to ensure test continues even if charts fail
            try {
              renderChart();
              renderWordsScatterChart();
            } catch (chartErr) {
              console.error("Chart error:", chartErr);
            }

            // Start the new test IMMEDIATELY without any delay
            startTest();
          } catch (err) {
            console.error("Error during test completion:", err);
            // Fallback to restart test if any error occurs
            startTest();
          }
        }
      } else if (currentWordEl) {
        currentWordEl.classList.add("incorrect");
      }
    });

    document.getElementById("input").addEventListener("keydown", function (e) {
      if (e.key === " ") {
        e.preventDefault();
        const word = this.value.trim();
        const expected = testWords[currentIndex];

        if (!expected || word !== expected) return;
        if (currentIndex === testWords.length - 1) return; // Don't handle last word with space

        handleCorrectWord(expected);
        this.value = "";
        renderWords();
      } else if (e.key === "Escape" || e.key === "Tab") {
        e.preventDefault();
        startTest();
      }
    });

    // Remove the delayed restart from showResults since we handle it directly in the input handler
    function showResults() {
      // Calculate statistics but don't try to restart the test
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
        return { word, avg5 };
      });

      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? (slow10.map(e => e.avg5).reduce((a, b) => a + b, 0) / slow10.length) : 0;

      if (!isNaN(avgOf10)) {
        slow10WPMHistory.push(parseFloat(avgOf10.toFixed(1)));
      }

      // Calculate overall WPM for the whole test
      const totalCharCount = testWords.reduce((sum, word) => sum + word.length, 0);
      const spacesCount = testWords.length - 1;
      const totalTimeMin = (performance.now() - testStartTime) / 1000 / 60;
      const overallWPM = ((totalCharCount + spacesCount) / 5) / totalTimeMin;

      // Save the overall WPM for the chart
      testWPMHistory.push(parseFloat(overallWPM.toFixed(1)));

      saveStatsToStorage();
      updateResultsDisplay();
      renderChart();
      renderWordsScatterChart();
    }

    // Update startTest to display results
    function startTest() {
      testWords = getTestWords();
      currentIndex = 0;
      testStartTime = null;
      startTime = null;
      document.getElementById("input").value = "";
      history = [];
      renderWords();
      renderStats();
      renderChart();
      renderWordsScatterChart();
      updateResultsDisplay(); // Show statistics immediately
      document.getElementById("input").focus();
    }

    // Call updateResultsDisplay after loading stats
    function loadStatsFromStorage() {
      const stats = localStorage.getItem('wordStats');
      const historyData = localStorage.getItem('slow10WPMHistory');
      const testHistoryData = localStorage.getItem('testWPMHistory');
      if (stats) {
        try { wordStats = JSON.parse(stats); } catch { }
      }
      if (historyData) {
        try { slow10WPMHistory = JSON.parse(historyData); } catch { }
      }
      if (testHistoryData) {
        try { testWPMHistory = JSON.parse(testHistoryData); } catch { }
      }
      updateResultsDisplay(); // Update results after loading stats
    }

    function saveStatsToStorage() {
      localStorage.setItem('wordStats', JSON.stringify(wordStats));
      localStorage.setItem('slow10WPMHistory', JSON.stringify(slow10WPMHistory));
      localStorage.setItem('testWPMHistory', JSON.stringify(testWPMHistory));
    }

    function resetStats() {
      wordStats = {};
      slow10WPMHistory = [];
      testWPMHistory = [];
      saveStatsToStorage();
      startTest();
    }

    function getTestWords() {
      if (Object.keys(wordStats).length === 0) {
        return english1k.sort(() => 0.5 - Math.random()).slice(0, 20);
      }
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      const random = english1k.sort(() => 0.5 - Math.random()).slice(0, 10);
      return [...new Set([...slowestWords, ...random])].slice(0, 20);
    }

    function renderWords() {
      const container = document.getElementById("wordList");
      container.innerHTML = testWords.map((word, i) => {
        let cls = "";
        if (i === currentIndex) cls = "current";
        else if (i < currentIndex) cls = "correct";
        if (slowestWords.includes(word)) cls += " highlight"; // Highlight slowest words
        return `<span class="${cls}">${word}</span>`;
      }).join(" ");
    }

    function renderStats() {
      const statsDiv = document.getElementById("stats");
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : 0;
        return {
          word,
          count: data.count || 0,
          avg5,
          avg: data.avg,
          last: data.last
        };
      });

      // Sort entries based on current sort column and direction
      entries.sort((a, b) => {
        let valueA = a[currentSortColumn];
        let valueB = b[currentSortColumn];

        // Special handling for text column (word)
        if (currentSortColumn === 'word') {
          return currentSortDirection === 'asc'
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);
        }

        // Numerical columns
        return currentSortDirection === 'asc'
          ? valueA - valueB
          : valueB - valueA;
      });

      // Create table with clickable headers
      let html = '<h2>Word Stats</h2><table><tr>';

      // Define column structure for easier maintenance
      const columns = [
        { id: 'index', label: '#', sortable: false },
        { id: 'word', label: 'Word', sortable: true },
        { id: 'count', label: 'Count', sortable: true },
        { id: 'avg5', label: 'Avg Last 5', sortable: true },
        { id: 'avg', label: 'Overall Avg', sortable: true },
        { id: 'last', label: 'Last', sortable: true }
      ];

      // Generate headers
      columns.forEach(column => {
        if (column.sortable) {
          const sortIcon = currentSortColumn === column.id
            ? (currentSortDirection === 'asc' ? '▲' : '▼')
            : '';
          html += `<th data-sort="${column.id}" class="sortable">${column.label} ${sortIcon}</th>`;
        } else {
          html += `<th>${column.label}</th>`;
        }
      });

      html += '</tr>';

      // Generate table rows
      entries.forEach((entry, idx) => {
        const rowClass = idx < 10 ? 'highlight' : '';
        html += `<tr class="${rowClass}">
          <td>${idx + 1}</td>
          <td>${entry.word}</td>
          <td>${entry.count}</td>
          <td>${entry.avg5.toFixed(1)}</td>
          <td>${entry.avg.toFixed(1)}</td>
          <td>${entry.last.toFixed(1)}</td>
        </tr>`;
      });

      html += '</table>';
      statsDiv.innerHTML = html;

      // Add event listeners to sortable headers
      document.querySelectorAll('.sortable').forEach(header => {
        header.addEventListener('click', function () {
          const column = this.getAttribute('data-sort');

          // Toggle direction if same column, otherwise set to asc
          if (column === currentSortColumn) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortColumn = column;
            currentSortDirection = 'asc';
          }

          renderStats();
        });
      });
    }

    // Update the line chart to display average values directly on lines
    function renderChart() {
      // Make sure we have data to show
      if (testWPMHistory.length === 0) return;

      // Calculate rolling average of the overall test WPMs (last 5 tests)
      const avg5Line = [];
      for (let i = 0; i < testWPMHistory.length; i++) {
        const slice = testWPMHistory.slice(Math.max(0, i - 4), i + 1);
        avg5Line.push(slice.reduce((a, b) => a + b, 0) / slice.length);
      }

      // Get the latest values for display
      const lastSlow10Avg = slow10WPMHistory.length > 0 ?
        slow10WPMHistory[slow10WPMHistory.length - 1].toFixed(1) : "0.0";
      const lastAvg5 = avg5Line.length > 0 ?
        avg5Line[avg5Line.length - 1].toFixed(1) : "0.0";

      const ctx = document.getElementById("wpmChart").getContext("2d");
      try {
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({ length: testWPMHistory.length }, (_, i) => i + 1),
            datasets: [
              {
                label: `Avg WPM of 10 Slowest Words: ${lastSlow10Avg} WPM`,
                data: slow10WPMHistory,
                borderColor: 'blue',
                backgroundColor: 'blue',
                fill: false,
                tension: 0.3,
                pointRadius: 4
              },
              {
                label: `Rolling Avg of Overall Tests: ${lastAvg5} WPM`,
                data: avg5Line,
                borderColor: 'orange',
                backgroundColor: 'orange',
                fill: false,
                borderDash: [5, 5],
                tension: 0.3,
                pointRadius: 4
              }
            ]
          },
          options: {
            plugins: {
              title: {
                display: true,
                text: 'WPM Performance Over Time'
              },
              legend: {
                display: true,
                position: 'top',
                labels: {
                  boxWidth: 15,
                  padding: 15,
                  font: {
                    weight: 'bold'
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Test #' } },
              y: { title: { display: true, text: 'WPM' }, beginAtZero: true }
            }
          }
        });
      } catch (err) {
        console.error("Error rendering chart:", err);
      }
    }

    // Update the scatter chart to display average values directly on lines
    function renderWordsScatterChart() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : 0;
        return { word, avg5 };
      });

      // Sort entries by avg5 (slowest to fastest)
      entries.sort((a, b) => a.avg5 - b.avg5);

      // Set maximum y value to 2x the median for better outlier handling
      const medianIndex = Math.floor(entries.length / 2);
      const medianWPM = entries.length ? entries[medianIndex]?.avg5 || 0 : 0;
      const maxYValue = Math.max(medianWPM * 2, 100); // Ensure reasonable minimum scale

      // Filter out extreme outliers that would make the chart unreadable
      const filteredEntries = entries.filter(entry => entry.avg5 <= maxYValue * 2);

      // Calculate averages ONLY from filtered/displayed data
      const allWordsAvg = filteredEntries.length ?
        filteredEntries.reduce((sum, entry) => sum + entry.avg5, 0) / filteredEntries.length : 0;

      const slow10Avg = filteredEntries.length ?
        filteredEntries.slice(0, Math.min(10, filteredEntries.length))
          .reduce((sum, entry) => sum + entry.avg5, 0) / Math.min(10, filteredEntries.length) : 0;

      // Map filtered entries to data points
      const dataPoints = filteredEntries.map((entry, index) => ({
        x: index + 1,
        y: entry.avg5,
        originalWord: entry.word
      }));

      const ctx = document.getElementById("wordsScatterChart").getContext("2d");

      // Niszcz poprzedni wykres rozproszony, jeśli istnieje
      if (scatterChart) {
        scatterChart.destroy();
      }

      // Utwórz nowy wykres i zapisz referencję
      scatterChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Words by WPM (Slowest to Fastest)',
              data: dataPoints,
              backgroundColor: dataPoints.map((_, index) =>
                index < 10 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 0.5)'
              ),
              pointRadius: 6,
              pointHoverRadius: 8
            },
            {
              label: `Average WPM (All Words): ${allWordsAvg.toFixed(1)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: allWordsAvg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 2,
              borderDash: [5, 5]
            },
            {
              label: `Average WPM (10 Slowest Words): ${slow10Avg.toFixed(1)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: slow10Avg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(255, 159, 64, 1)',
              borderWidth: 2,
              borderDash: [10, 5]
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Words Ranked by Speed (Slowest to Fastest)'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  if (context.datasetIndex === 0) {
                    return `"${context.raw.originalWord}": ${context.parsed.y.toFixed(1)} WPM`;
                  } else if (context.datasetIndex === 1) {
                    return `Average WPM (All Words): ${allWordsAvg.toFixed(1)}`;
                  } else {
                    return `Average WPM (10 Slowest Words): ${slow10Avg.toFixed(1)}`;
                  }
                }
              }
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                boxWidth: 15,
                padding: 15,
                font: {
                  weight: 'bold'
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Word Rank'
              },
              ticks: {
                stepSize: 1
              }
            },
            y: {
              title: {
                display: true,
                text: 'WPM (Avg Last 5)'
              },
              beginAtZero: true,
              suggestedMax: maxYValue // Limit y-axis to 2x average, but data points can exceed it
            }
          }
        }
      });
    }

    // Update handleCorrectWord to refresh stats after each word
    function handleCorrectWord(word) {
      const now = performance.now();
      const duration = (now - startTime) / 1000 / 60; // czas w minutach

      // Oblicz WPM przy użyciu liczby znaków / 5
      const wordLetterCount = word.length;
      const wpm = (wordLetterCount / 5) / duration; // Calculate WPM based on letter count

      if (!wordStats[word]) {
        wordStats[word] = {
          avg: wpm,
          last: wpm,
          last5: [wpm],
          count: 1  // Initialize count to 1 for new words
        };
      } else {
        wordStats[word].avg = (wordStats[word].avg * 0.8 + wpm * 0.2);
        wordStats[word].last = wpm;
        wordStats[word].last5 = (wordStats[word].last5 || []).slice(-4).concat(wpm);
        wordStats[word].count = (wordStats[word].count || 0) + 1; // Increment count
      }

      // Update slowestWords list immediately after each word is typed
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      saveStatsToStorage();
      history.push({ word, wpm });
      currentIndex++;
      startTime = now;

      // Add this line to refresh the stats table after each word
      renderStats();
    }

    function toggleTheme() {
      const dark = document.body.classList.toggle("dark");
      localStorage.setItem('theme', dark ? 'dark' : 'light');
    }

    function loadTheme() {
      const theme = localStorage.getItem('theme');
      if (theme === "dark") {
        document.body.classList.add("dark");
      }
    }

    function refreshCharts() {
      try {
        renderChart();
        renderWordsScatterChart();
      } catch (err) {
        console.error("Error refreshing charts:", err);
      }
    }

    loadTheme();

    fetch('https://raw.githubusercontent.com/SMenigat/thousand-most-common-words/master/words/en.json')
      .then(res => res.json())
      .then(data => {
        // Clean up apostrophes in words
        english1k = data.words
          .map(w => w.englishWord)
          .filter(w => w)
          .map(word => word.replace(/’/g, "'"));
        loadStatsFromStorage();
        startTest();
      });
  </script>
</body>

</html>
