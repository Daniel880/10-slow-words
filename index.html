<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>10 Slow Words</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      padding: 20px;
      background-color: #fff;
      color: #000;
    }

    .dark {
      background-color: #121212;
      color: #e0e0e0;
    }

    .word-list {
      margin-bottom: 20px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 3em;
    }

    .word-list span {
      margin-right: 5px;
    }

    .current-word {
      /* Highlighting for current word without underlining the entire word */
    }

    /* Remove spacing between characters in the current word */
    .current-word span {
      margin-right: 0;
      letter-spacing: normal;
    }

    .correct {
      color: green;
    }

    .incorrect {
      color: red;
    }

    input {
      width: 100%;
      font-family: 'JetBrains Mono', monospace;
      font-size: 3em;
      padding: 5px;
    }

    .results,
    .stats {
      margin-top: 20px;
    }

    .highlight {
      font-weight: bold;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
      font-family: 'JetBrains Mono', monospace;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f0f0f0;
    }

    .dark th,
    .dark td {
      background-color: #1e1e1e;
      color: #fff;
      border-color: #333;
    }

    .dark th {
      background-color: #2e2e2e;
    }

    .dark input {
      background-color: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
    }

    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
      font-family: 'JetBrains Mono', monospace;
    }

    .global-stats {
      display: flex;
      gap: 2em;
      font-size: 1.2em;
      margin-bottom: 10px;
    }

    .word-tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      display: none;
      width: 1100px;
      /* Fixed width instead of max-width */
      height: 450px;
      /* Fixed height instead of max-height */
      overflow: visible;
    }

    .dark .word-tooltip {
      background: #222;
      border-color: #444;
      color: #fff;
    }

    .tooltip-canvas {
      width: 100% !important;
      /* Force width with !important */
      height: 400px !important;
      /* Force height with !important */
      display: block;
    }

    .word-cell {
      cursor: pointer;
      text-decoration: underline dotted;
    }

    /* Ensure table cells are square */
    #confusionMatrix table {
      table-layout: fixed;
    }

    #confusionMatrix th,
    #confusionMatrix td {
      width: 10px;
      /* Set a fixed width */
      height: 10px;
      /* Set a fixed height */
      text-align: center;
      /* Center text */
      vertical-align: middle;
      /* Center text vertically */
    }
  </style>
</head>

<body>
  <h1>10 Slow Words</h1>
  <div class="word-list" id="wordList"></div>
  <input type="text" id="input" placeholder="Start typing..." autofocus />
  <div class="results" id="results"></div>

  <!-- Performance chart container with better visibility - before stats table -->
  <div id="performanceChartContainer"
    style="margin: 30px 0; padding: 20px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9;">
    <h3 style="margin-top: 0;">Performance History</h3>
    <canvas id="wpmChart" width="800" height="300"></canvas>
    <button onclick="togglePerformanceChart()" style="padding: 4px 8px; font-size: 0.8em; margin: 5px 0;">Hide
      Performance Chart</button>
  </div>

  <!-- Words scatter chart container - between performance chart and stats table -->
  <div id="wordsScatterContainer"
    style="margin: 30px 0; padding: 20px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9;">
    <h3 style="margin-top: 0;">Words Ranked by Speed (Slowest to Fastest)</h3>
    <canvas id="wordsScatterChart" width="800" height="400"></canvas>
    <button onclick="toggleScatterChart()" style="padding: 4px 8px; font-size: 0.8em; margin: 5px 0;">Hide
      Words Chart</button>
  </div>

  <!-- Stats table will be rendered here -->
  <div id="statsContainer">
    <div id="stats"></div>
  </div>

  <button onclick="resetStats()">Reset All Stats</button>
  <button onclick="toggleTheme()">Toggle Dark Mode</button>
  <button onclick="refreshCharts()">Refresh Charts</button>
  <button onclick="renderConfusionMatrix()">Show Confusion Matrix</button>
  <div id="confusionMatrix"></div>

  <script>
    let english1k = [];
    let testWords = [];
    let startTime = null;
    let testStartTime;
    let currentIndex = 0;
    let wordStats = {};
    let history = [];
    let slowestWords = [];
    let chart;
    let scatterChart;
    let slow10WPMHistory = [];
    let testWPMHistory = [];
    let wordStartTime = null;
    let currentSortColumn = 'avg5';
    let currentSortDirection = 'asc';

    let lastKey = null; // Tracks the last key pressed
    let lastKeyTime = null; // Tracks the timestamp of the last key press
    let keyPressTimings = []; // To store timings between keypresses

    // Load pair timings from localStorage
    let pairTimings = loadFromLocalStorage("pairTimings") || {};

    // Save pair timings to localStorage
    function savePairTimings() {
      saveToLocalStorage("pairTimings", pairTimings);
    }

    // Utility functions for repeated calculations
    const utils = {
      calculateAverage: (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0,
      formatNumber: (num, decimals = 1) => Number.isFinite(num) ? num.toFixed(decimals) : "-",
      getColorScheme: () => document.body.classList.contains('dark') ?
        { primary: 'rgb(75, 192, 255)', primaryAlpha: 'rgba(75, 192, 255, 0.2)' } :
        { primary: 'rgb(75, 192, 192)', primaryAlpha: 'rgba(75, 192, 192, 0.2)' }
    };

    // Utility functions for localStorage
    function saveToLocalStorage(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    function loadFromLocalStorage(key) {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }

    // Add a helper function to store all history for each word
    function updateWordStats(word, wpm) {
      if (!wordStats[word]) {
        wordStats[word] = {
          avg: wpm,
          last: wpm,
          last5: [wpm],
          allHistory: [wpm], // New array to store all attempts
          count: 1
        };
      } else {
        wordStats[word].avg = (wordStats[word].avg * 0.8 + wpm * 0.2);
        wordStats[word].last = wpm;
        wordStats[word].last5 = (wordStats[word].last5 || []).slice(-4).concat(wpm);
        // Add to the full history array
        if (!wordStats[word].allHistory) wordStats[word].allHistory = [];
        wordStats[word].allHistory.push(wpm);
        wordStats[word].count = (wordStats[word].count || 0) + 1;
      }
    }

    function updateResultsDisplay() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
        return { word, avg5 };
      });

      // Calculate average WPM based on avg5 from all words
      const avgWPM = entries.length
        ? utils.formatNumber(utils.calculateAverage(entries.map(e => e.avg5).filter(avg => isFinite(avg))))
        : "-";

      // Calculate slowest 10 words WPM (already working correctly)
      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? utils.calculateAverage(slow10.map(e => e.avg5)) : 0;

      // Get last word WPM if history exists
      const lastWordEntry = history.length > 0 ? history[history.length - 1] : null;
      const lastWordWPM = lastWordEntry ? utils.formatNumber(lastWordEntry.wpm) : "-";
      const lastWord = lastWordEntry ? lastWordEntry.word : "";

      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = `
        <h2>Statistics</h2>
        <div class="global-stats">
          <div><strong>Last Word WPM (${lastWord}):</strong> ${lastWordWPM}</div>
          <div><strong>Average WPM:</strong> ${avgWPM}</div>
          <div><strong>Slowest 10 Words WPM:</strong> ${utils.formatNumber(avgOf10)}</div>
        </div>
      `;
    }

    // Update the chart generation function to use full history
    function generateWordProgressChart(word) {
      const data = wordStats[word];
      console.log('Generating chart for:', word, data);

      if (!data) {
        console.log('No data for word:', word);
        return false;
      }

      // Use all history if available, otherwise fall back to last5
      const chartData = data.allHistory || data.last5;

      if (!chartData || chartData.length === 0) {
        console.log('No chart data available for word:', word);
        return false;
      }

      const tooltipDiv = document.getElementById('wordTooltip');
      if (!tooltipDiv) {
        console.error('Tooltip div not found!');
        return false;
      }

      tooltipDiv.innerHTML = `
        <p>Progress for word "${word}" (${chartData.length} attempts)</p>
        <canvas id="tooltipChart" class="tooltip-canvas"></canvas>
      `;

      const canvas = document.getElementById('tooltipChart');
      if (!canvas) {
        console.error('Chart canvas element not found!');
        return false;
      }

      const ctx = canvas.getContext('2d');

      if (window.tooltipChart && typeof window.tooltipChart.destroy === 'function') {
        window.tooltipChart.destroy();
      }

      const labels = chartData.map((_, i) => `Attempt #${i + 1}`);
      const avgWPM = utils.calculateAverage(chartData);
      const colors = utils.getColorScheme();

      // Calculate trend line values
      const trendValues = [];
      if (chartData.length > 1) {
        // Simple linear regression
        const xValues = Array.from({ length: chartData.length }, (_, i) => i + 1);
        const xMean = utils.calculateAverage(xValues);
        const yMean = avgWPM;

        let numerator = 0;
        let denominator = 0;

        for (let i = 0; i < chartData.length; i++) {
          numerator += (xValues[i] - xMean) * (chartData[i] - yMean);
          denominator += Math.pow(xValues[i] - xMean, 2);
        }

        const slope = denominator ? numerator / denominator : 0;
        const intercept = yMean - (slope * xMean);

        // Generate the trend line data points
        for (let i = 0; i < chartData.length; i++) {
          trendValues.push(slope * (i + 1) + intercept);
        }
      }

      // Get first and last values for displaying improvement
      let improvement = "";
      if (chartData.length > 1) {
        const first = chartData[0];
        const last = chartData[chartData.length - 1];
        const changePercent = ((last - first) / first * 100).toFixed(1);
        improvement = ` (${changePercent > 0 ? '+' : ''}${changePercent}% from first attempt)`;
      }

      window.tooltipChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'WPM',
              data: chartData,
              borderColor: colors.primary,
              backgroundColor: colors.primaryAlpha,
              fill: true,
              tension: 0.3
            },
            // Add trend line if we have more than one data point
            ...(chartData.length > 1 ? [{
              label: 'Trend',
              data: trendValues,
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 2,
              borderDash: [5, 5],
              fill: false,
              pointRadius: 0
            }] : [])
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              left: 20,
              right: 30,
              top: 30,
              bottom: 20
            }
          },
          plugins: {
            title: {
              display: true,
              text: `Progress for "${word}" (Avg: ${utils.formatNumber(avgWPM)} WPM)${improvement}`,
              font: {
                size: 18
              }
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return `WPM: ${utils.formatNumber(context.parsed.y)}`;
                }
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: 'WPM',
                font: {
                  size: 14
                }
              },
              suggestedMin: Math.max(0, avgWPM * 0.5),
              suggestedMax: avgWPM * 1.5
            },
            x: {
              title: {
                display: true,
                text: 'Attempts',
                font: {
                  size: 14
                }
              }
            }
          }
        }
      });

      return true;
    }

    // Keep the same event handler implementations from your original code
    document.getElementById("input").addEventListener("input", function (e) {
      const typed = this.value;
      const expected = testWords[currentIndex];
      const wordListSpans = document.querySelectorAll("#wordList span");

      if (expected) {
        // Zamień aktualny wyraz na litery z kolorowaniem
        const currentSpan = wordListSpans[currentIndex];
        // Only start replacing characters with underscores once typing begins
        if (typed.length > 0) {
          let coloredWord = expected
            .split("")
            .map((char, idx) => {
              if (idx < typed.length) {
                // Show typed character instead of expected character when there's a mismatch
                return `<span style="color: ${typed[idx] === char ? 'green' : 'red'};">${typed[idx] === char ? char : typed[idx]}</span>`;
              } else {
                return "_"; // Use underscores instead of asterisks for untyped characters
              }
            })
            .join("");

          // Add any extra characters that exceed the word length
          if (typed.length > expected.length) {
            const extraChars = typed.substring(expected.length);
            coloredWord += extraChars
              .split("")
              .map(char => `<span style="color: red;">${char}</span>`)
              .join("");
          }

          currentSpan.innerHTML = coloredWord;
        } else {
          // If no typing has started yet, show the full word
          currentSpan.innerHTML = expected;
        }

        // Oznacz wyraz jako niepoprawny, jeśli wpis jest błędny
        if (!expected.startsWith(typed)) {
          currentSpan.classList.add("incorrect");
        } else {
          currentSpan.classList.remove("incorrect");
        }
      }
    });

    document.getElementById("input").addEventListener("keydown", function (e) {
      if (e.key === " ") {
        e.preventDefault();

        // Record the time for the space key if we've been tracking keystrokes
        const now = performance.now();
        if (lastKeyTime && this.value.trim() === testWords[currentIndex]) {
          const timeBetweenKeys = now - lastKeyTime;
          keyPressTimings.push({
            key: "space",
            timing: timeBetweenKeys
          });

          // Store the letter-to-space transition in pairTimings
          const word = testWords[currentIndex];
          const lastLetter = word[word.length - 1];
          const pairKey = `${lastLetter}->space`;

          if (!pairTimings[pairKey]) {
            pairTimings[pairKey] = {
              count: 0,
              occurrences: []
            };
          }

          pairTimings[pairKey].count++;
          pairTimings[pairKey].occurrences.push(timeBetweenKeys);

          // Keep only the last 100 occurrences to avoid excessive memory usage
          if (pairTimings[pairKey].occurrences.length > 100) {
            pairTimings[pairKey].occurrences.shift();
          }
        }

        const word = this.value.trim();
        const expected = testWords[currentIndex];

        if (!expected || word !== expected) return;

        handleCorrectWord(expected);
        this.value = "";

        if (currentIndex === testWords.length) {
          showResults();
          startTest(); // Reload the test after showing results
        } else {
          renderWords();
        }
      } else if (!wordStartTime &&
        !e.key.startsWith('Shift') &&
        !e.key.startsWith('Control') &&
        !e.key.startsWith('Alt') &&
        !e.key.startsWith('Meta') &&
        !e.key.startsWith('Arrow') &&
        !e.key.startsWith('Tab') &&
        !e.key.startsWith('Caps') &&
        !e.key.startsWith('Escape') &&
        !e.key.startsWith('F') &&
        e.key.length === 1) {
        wordStartTime = performance.now();
        lastKeyTime = wordStartTime; // Initialize lastKeyTime with wordStartTime for first letter
        keyPressTimings = []; // Reset timings for new word
      } else if (
        !e.key.startsWith('Shift') &&
        !e.key.startsWith('Control') &&
        !e.key.startsWith('Alt') &&
        !e.key.startsWith('Meta') &&
        !e.key.startsWith('Arrow') &&
        !e.key.startsWith('Tab') &&
        !e.key.startsWith('Caps') &&
        !e.key.startsWith('Escape') &&
        !e.key.startsWith('F') &&
        e.key.length === 1
      ) {
        // Record time between keypresses
        const now = performance.now();
        if (lastKeyTime) {
          const timeBetweenKeys = now - lastKeyTime;
          keyPressTimings.push({
            key: e.key,
            timing: timeBetweenKeys
          });

          // Also store letter-to-letter transitions in pairTimings
          if (this.value.length > 0) {
            const prevChar = this.value[this.value.length - 1] || "";
            const pairKey = `${prevChar}->${e.key}`;

            if (!pairTimings[pairKey]) {
              pairTimings[pairKey] = {
                count: 0,
                occurrences: []
              };
            }

            pairTimings[pairKey].count++;
            pairTimings[pairKey].occurrences.push(timeBetweenKeys);

            // Keep only the last 100 occurrences
            if (pairTimings[pairKey].occurrences.length > 100) {
              pairTimings[pairKey].occurrences.shift();
            }
          }
        }
        lastKeyTime = now;
      }
    });

    // Keep all your original functionality but make the code more maintainable
    function handleCorrectWord(word) {
      const now = performance.now();

      if (!wordStartTime) return;

      const duration = (now - wordStartTime) / 1000 / 60;
      wordStartTime = null;

      const wordLetterCount = word.length + 1;
      const wpm = (wordLetterCount / 5) / duration;

      // Render the keystroke timing chart before updating other stats
      renderKeystrokeTimingChart(word, wpm);
      lastKeyTime = null; // Reset last key time

      // Update stats for the word
      updateWordStats(word, wpm);

      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      saveStatsToStorage();
      history.push({ word, wpm });
      currentIndex++;

      // Check if the test is finished
      if (currentIndex >= testWords.length) {
        showResults();
        startTest(); // Immediately reset the test
      } else {
        renderWords();
      }

      // Re-render the stats table and update statistics display after each word
      renderStats();
      updateResultsDisplay(); // Add this line to update the statistics after each word
    }

    function renderKeystrokeTimingChart(word, overallWPM) {
      if (keyPressTimings.length === 0) return;

      // Create a div for the chart if it doesn't exist
      let chartDiv = document.getElementById("keystrokeChart");
      if (!chartDiv) {
        chartDiv = document.createElement("div");
        chartDiv.id = "keystrokeChart";
        chartDiv.style.marginTop = "20px";
        chartDiv.style.marginBottom = "20px";

        // Create the canvas first with increased height
        const canvas = document.createElement("canvas");
        canvas.id = "keystrokeCanvas";
        canvas.width = 800;
        canvas.height = 200; // Increased to 2x the current height
        chartDiv.appendChild(canvas);

        // Add a toggle button below the chart (with smaller styling)
        const toggleButton = document.createElement("button");
        toggleButton.textContent = "Hide Keystroke Chart";
        toggleButton.onclick = toggleKeystrokeChart;
        toggleButton.style.padding = "4px 8px"; // Smaller padding
        toggleButton.style.fontSize = "0.8em"; // Smaller font
        toggleButton.style.margin = "5px 0"; // Reduced margin
        chartDiv.appendChild(toggleButton);

        // Insert before the stats div
        const statsDiv = document.getElementById("stats");
        statsDiv.parentNode.insertBefore(chartDiv, statsDiv);
      }

      // Calculate WPM for each keystroke timing with a corrected formula
      // The previous formula wasn't aligned with the Overall WPM calculation
      const wpmValues = keyPressTimings.map(timing => ({
        key: timing.key,
        // Convert milliseconds to characters per minute, then to words per minute
        // 60000 ms in a minute / timing in ms = keypresses per minute
        // Then divide by 5 to get words per minute (standard 5 chars = 1 word)
        wpm: (60000 / timing.timing) / 5
      }));

      // Use a simpler approach for transitions
      const labels = [];
      const chartWpmValues = [];
      const historicalWpmValues = []; // Array for historical average WPM values

      // Add letter transitions based on key press order
      for (let i = 0; i < keyPressTimings.length; i++) {
        const currentKey = keyPressTimings[i].key;

        if (currentKey === "space") {
          // Special case for space key
          const transitionKey = `${word[word.length - 1]}->"space"`;
          labels.push(transitionKey);
          chartWpmValues.push(wpmValues[i].wpm);

          // Get historical data for this transition
          const pairKey = `${word[word.length - 1]}->space`;
          const historicalData = pairTimings[pairKey];
          if (historicalData && historicalData.occurrences && historicalData.occurrences.length > 0) {
            const last10 = historicalData.occurrences.slice(-10);
            const avgTime = last10.length ? last10.reduce((a, b) => a + b, 0) / last10.length : 0;
            // Convert to WPM using the same formula
            const historicalWpm = avgTime > 0 ? (60000 / avgTime) / 5 : 0;
            historicalWpmValues.push(historicalWpm);
          } else {
            // No historical data for this transition
            historicalWpmValues.push(null);
          }
        } else if (i < word.length) {
          // For normal letter transitions
          const currentPos = i;
          const nextPos = i + 1;

          if (nextPos < word.length) {
            const transitionKey = `${word[currentPos]}->${word[nextPos]}`;
            labels.push(transitionKey);
            chartWpmValues.push(wpmValues[i].wpm);

            // Get historical data for this transition
            const pairKey = `${word[currentPos]}->${word[nextPos]}`;
            const historicalData = pairTimings[pairKey];
            if (historicalData && historicalData.occurrences && historicalData.occurrences.length > 0) {
              const last10 = historicalData.occurrences.slice(-10);
              const avgTime = last10.length ? last10.reduce((a, b) => a + b, 0) / last10.length : 0;
              // Convert to WPM using the same formula
              const historicalWpm = avgTime > 0 ? (60000 / avgTime) / 5 : 0;
              historicalWpmValues.push(historicalWpm);
            } else {
              // No historical data for this transition
              historicalWpmValues.push(null);
            }
          }
        }
      }

      // Add debug info
      console.log("Word:", word);
      console.log("Overall WPM:", overallWPM);
      console.log("Key timings (ms):", keyPressTimings.map(t => t.timing));
      console.log("Keystroke WPMs:", wpmValues.map(v => v.wpm.toFixed(1)));

      // Get the keystroke canvas and create/update the chart
      const canvas = document.getElementById("keystrokeCanvas");
      const ctx = canvas.getContext("2d");

      // Destroy any existing chart
      if (window.keystrokeChart && typeof window.keystrokeChart.destroy === 'function') {
        window.keystrokeChart.destroy();
      }

      // Only create the chart if we have valid data
      if (labels.length > 0 && chartWpmValues.length > 0) {
        window.keystrokeChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Current Keystroke WPM',
                data: chartWpmValues,
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                pointRadius: 6,
                pointHoverRadius: 8
              },
              {
                label: 'Historical Avg WPM (Last 10)',
                data: historicalWpmValues,
                backgroundColor: 'rgba(255, 159, 64, 0.5)',
                borderColor: 'rgba(255, 159, 64, 1)',
                borderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6,
                pointStyle: 'triangle'
              },
              {
                label: `Overall Word WPM: ${utils.formatNumber(overallWPM)}`,
                data: Array(labels.length).fill(overallWPM),
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              title: {
                display: true,
                text: `Keystroke Timing for "${word}" (${utils.formatNumber(overallWPM)} WPM)`,
                font: {
                  size: 16
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    if (context.datasetIndex === 0) {
                      return `Current WPM: ${utils.formatNumber(context.parsed.y)}`;
                    } else if (context.datasetIndex === 1) {
                      return `Historical Avg WPM: ${context.parsed.y ? utils.formatNumber(context.parsed.y) : "No data"}`;
                    } else {
                      return `Overall Word WPM: ${utils.formatNumber(overallWPM)}`;
                    }
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: false,
                title: {
                  display: true,
                  text: 'WPM'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Letter Transitions'
                }
              }
            }
          }
        });
      }
    }

    // Add this function to toggle the keystroke chart visibility
    function toggleKeystrokeChart() {
      const chartDiv = document.getElementById("keystrokeChart");
      const canvas = document.getElementById("keystrokeCanvas");
      const button = chartDiv.querySelector("button");

      if (canvas.style.display === "none") {
        // Show the chart
        canvas.style.display = "block";
        button.textContent = "Hide Keystroke Chart";
      } else {
        // Hide the chart
        canvas.style.display = "none";
        button.textContent = "Show Keystroke Chart";
      }
    }

    // Add toggle function for performance chart
    function togglePerformanceChart() {
      const chartContainer = document.getElementById("performanceChartContainer");
      const canvas = document.getElementById("wpmChart");
      const button = chartContainer.querySelector("button");

      if (canvas.style.display === "none") {
        // Show the chart
        canvas.style.display = "block";
        button.textContent = "Hide Performance Chart";
      } else {
        // Hide the chart
        canvas.style.display = "none";
        button.textContent = "Show Performance Chart";
      }
    }

    // Add toggle function for scatter chart (similar to performance chart)
    function toggleScatterChart() {
      const chartContainer = document.getElementById("wordsScatterContainer");
      const canvas = document.getElementById("wordsScatterChart");
      const button = chartContainer.querySelector("button");

      if (canvas.style.display === "none") {
        // Show the chart
        canvas.style.display = "block";
        button.textContent = "Hide Words Chart";
      } else {
        // Hide the chart
        canvas.style.display = "none";
        button.textContent = "Show Words Chart";
      }
    }

    function showResults() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
        return { word, avg5 };
      });

      // Sort entries to get the slowest words correctly
      entries.sort((a, b) => a.avg5 - b.avg5);

      const slow10 = entries.slice(0, 10);
      const avgOf10 = slow10.length ? utils.calculateAverage(slow10.map(e => e.avg5)) : 0;

      // Calculate test duration and verify it's valid
      const totalTimeMin = (performance.now() - testStartTime) / 1000 / 60;

      // Only add to history if the test has proper timing and we have data
      if (totalTimeMin > 0 && testStartTime) {
        slow10WPMHistory.push(avgOf10);

        const avgWPM = entries.length
          ? utils.calculateAverage(entries.map(e => e.avg5).filter(avg => isFinite(avg)))
          : 0;
        testWPMHistory.push(avgWPM);

        saveStatsToStorage();
      }

      updateResultsDisplay();
      renderChart();
      renderWordsScatterChart();
    }

    function renderChart() {
      if (testWPMHistory.length === 0) return;

      // No need to manually calculate min/max - let Chart.js handle it automatically

      const ctx = document.getElementById("wpmChart").getContext("2d");
      try {
        if (chart) chart.destroy();

        // Get the last values directly from the arrays, without recalculation
        const lastSlow10Avg = slow10WPMHistory.length > 0 ?
          utils.formatNumber(slow10WPMHistory[slow10WPMHistory.length - 1]) : "0.0";
        const lastAvgWPM = testWPMHistory.length > 0 ?
          utils.formatNumber(testWPMHistory[testWPMHistory.length - 1]) : "0.0";

        // Calculate moving average for slow10WPMHistory
        const movingAvgWindowSize = 20; // Use a window of 3 points
        const movingAvgSlow10 = slow10WPMHistory.map((val, idx, arr) => {
          if (idx < movingAvgWindowSize - 1) {
            // For the first few points where we don't have enough previous data
            return null;
          }

          // Calculate average of last N values
          const window = arr.slice(idx - (movingAvgWindowSize - 1), idx + 1);
          return utils.calculateAverage(window);
        });

        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({ length: testWPMHistory.length }, (_, i) => i + 1),
            datasets: [
              {
                label: `Avg WPM of 10 Slowest Words: ${lastSlow10Avg} WPM`,
                data: slow10WPMHistory,
                borderColor: 'blue',
                backgroundColor: 'blue',
                fill: false,
                tension: 0.3,
                pointRadius: 4
              },
              {
                label: `Moving Avg (${movingAvgWindowSize}) of 10 Slowest Words`,
                data: movingAvgSlow10,
                borderColor: 'rgba(75, 0, 130, 0.7)', // Indigo color
                backgroundColor: 'rgba(75, 0, 130, 0.7)',
                fill: false,
                borderWidth: 2,
                tension: 0.4,
                pointRadius: 0, // No points, just the line
                borderDash: [3, 3] // Dashed line
              },
              {
                label: `Average WPM: ${lastAvgWPM} WPM`,
                data: testWPMHistory,
                borderColor: 'orange',
                backgroundColor: 'orange',
                fill: false,
                borderDash: [5, 5],
                tension: 0.3,
                pointRadius: 4
              }
            ]
          },
          options: {
            plugins: {
              title: {
                display: true,
                text: 'WPM Performance Over Time'
              },
              legend: {
                display: true,
                position: 'top',
                labels: {
                  boxWidth: 15,
                  padding: 15,
                  font: {
                    weight: 'bold'
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Test #' } },
              y: {
                title: { display: true, text: 'WPM' },
                // Let Chart.js handle the axis bounds automatically
                // Remove beginAtZero to avoid constraining the lower bound
                // Add padding to give some space above and below the data points
                ticks: {
                  padding: 10
                },
                grace: '10%' // Add 10% padding to both ends of the axis
              }
            }
          }
        });
      } catch (err) {
        console.error("Error rendering chart:", err);
      }
    }

    // Maintain all the other functions with small improvements
    function startTest() {
      testWords = getTestWords();
      currentIndex = 0;
      testStartTime = performance.now(); // Explicitly set start time immediately
      startTime = null;
      document.getElementById("input").value = "";
      const input = document.getElementById("input");
      if (testWords[currentIndex]) {
        input.placeholder = testWords[currentIndex];
      } else {
        input.placeholder = "Start typing...";
      }
      history = [];
      renderWords();
      renderStats();
      renderChart();
      renderWordsScatterChart();
      updateResultsDisplay();
      document.getElementById("input").focus();

      // Remove the "TEST" word initialization
      if (Object.keys(wordStats).length === 0) {
        wordStats = {}; // Ensure stats are empty if no prior data exists
      }
    }

    function loadStatsFromStorage() {
      const stats = localStorage.getItem('wordStats');
      const historyData = localStorage.getItem('slow10WPMHistory');
      const testHistoryData = localStorage.getItem('testWPMHistory');
      if (stats) {
        try { wordStats = JSON.parse(stats); } catch { }
      }
      if (historyData) {
        try { slow10WPMHistory = JSON.parse(historyData); } catch { }
      }
      if (testHistoryData) {
        try { testWPMHistory = JSON.parse(testHistoryData); } catch { }
      }
      updateResultsDisplay();
    }

    function saveStatsToStorage() {
      localStorage.setItem('wordStats', JSON.stringify(wordStats));
      localStorage.setItem('slow10WPMHistory', JSON.stringify(slow10WPMHistory));
      localStorage.setItem('testWPMHistory', JSON.stringify(testWPMHistory));
    }

    function resetStats() {
      wordStats = {};
      slow10WPMHistory = [];
      testWPMHistory = [];
      pairTimings = {};
      saveStatsToStorage();
      startTest();
    }

    function getTestWords() {
      if (Object.keys(wordStats).length === 0) {
        return english1k.sort(() => 0.5 - Math.random()).slice(0, 20);
      }
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      const random = english1k.sort(() => 0.5 - Math.random()).slice(0, 10);
      return [...new Set([...slowestWords, ...random])].slice(0, 20);
    }

    function renderWords() {
      const container = document.getElementById("wordList");

      // Update input placeholder to show the current word
      const input = document.getElementById("input");
      if (testWords[currentIndex]) {
        input.placeholder = testWords[currentIndex];
      } else {
        input.placeholder = "Start typing...";
      }

      container.innerHTML = testWords.map((word, i) => {
        let cls = "";
        let displayWord = word; // Default to showing the full word
        let wordStyle = ""; // Initialize wordStyle as empty

        if (i === currentIndex) {
          // Add current class for positioning but not for underlining
          cls = "current-word"; // Changed from "current" to avoid global underline
          const inputValue = document.getElementById("input").value;
          // Only replace with underscores if typing has started
          if (inputValue.length > 0) {
            displayWord = word.split("").map((char, idx) => {
              if (idx < inputValue.length) {
                return `<span>${char}</span>`; // Show typed characters
              } else {
                return `<span style="text-decoration: underline;">_</span>`; // Show underscores for untyped characters
              }
            }).join("");
          }
          // If no typing has occurred, keep the full word visible
        } else if (i < currentIndex) {
          cls = "correct";
          // Only apply bold style for slow words after they've been typed correctly
          if (slowestWords.includes(word)) {
            wordStyle = "font-weight: bold;";
          }
        } else {
          displayWord = "_".repeat(word.length); // Show underscores for future words
        }

        return `<span class="${cls}" data-index="${i}" style="${wordStyle}">${displayWord}</span>`;
      }).join(" ");
    }

    function renderStats() {
      const statsDiv = document.getElementById("stats");
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : 0;
        return {
          word,
          count: data.count || 0,
          avg5,
          avg: data.avg,
          last: data.last
        };
      });

      entries.sort((a, b) => {
        let valueA = a[currentSortColumn];
        let valueB = b[currentSortColumn];

        if (currentSortColumn === 'word') {
          return currentSortDirection === 'asc'
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);
        }

        return currentSortDirection === 'asc'
          ? valueA - valueB
          : valueB - valueA;
      });

      let html = '<h2>Word Stats</h2><table><tr>';

      const columns = [
        { id: 'index', label: '#', sortable: false },
        { id: 'word', label: 'Word', sortable: true },
        { id: 'count', label: 'Count', sortable: true },
        { id: 'avg5', label: 'Avg Last 5', sortable: true },
        { id: 'avg', label: 'Overall Avg', sortable: true },
        { id: 'last', label: 'Last', sortable: true }
      ];

      columns.forEach(column => {
        if (column.sortable) {
          const sortIcon = currentSortColumn === column.id
            ? (currentSortDirection === 'asc' ? '▲' : '▼')
            : '';
          html += `<th data-sort="${column.id}" class="sortable">${column.label} ${sortIcon}</th>`;
        } else {
          html += `<th>${column.label}</th>`;
        }
      });

      html += '</tr>';

      entries.forEach((entry, idx) => {
        const rowClass = idx < 10 ? 'highlight' : '';
        html += `<tr class="${rowClass}">
          <td>${idx + 1}</td>
          <td class="word-cell" data-word="${entry.word}">${entry.word}</td>
          <td>${entry.count}</td>
          <td>${utils.formatNumber(entry.avg5)}</td>
          <td>${utils.formatNumber(entry.avg)}</td>
          <td>${utils.formatNumber(entry.last)}</td>
        </tr>`;
      });

      html += '</table>';
      statsDiv.innerHTML = html;

      document.querySelectorAll('.sortable').forEach(header => {
        header.addEventListener('click', function () {
          const column = this.getAttribute('data-sort');

          if (column === currentSortColumn) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortColumn = column;
            currentSortDirection = 'asc';
          }

          renderStats();
        });
      });

      const tooltipDiv = document.getElementById("wordTooltip");
      if (!tooltipDiv) {
        console.error("Tooltip div not found!");
        return;
      }

      document.querySelectorAll('.word-cell').forEach(cell => {
        const word = cell.getAttribute('data-word');

        cell.addEventListener('mouseenter', (e) => {
          console.log('Mouse entered cell for word:', word);
          const result = generateWordProgressChart(word);
          if (result) {
            tooltipDiv.style.display = 'block';
            tooltipDiv.style.left = `${e.pageX + 15}px`;
            tooltipDiv.style.top = `${e.pageY + 15}px`;
          } else {
            console.log('No chart data available for word:', word);
          }
        });

        cell.addEventListener('mouseleave', () => {
          tooltipDiv.style.display = 'none';
        });

        cell.addEventListener('mousemove', (e) => {
          tooltipDiv.style.left = `${e.pageX + 15}px`;
          tooltipDiv.style.top = `${e.pageY + 15}px`;
        });
      });
    }

    function renderWordsScatterChart() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : 0;
        return { word, avg5 };
      });

      entries.sort((a, b) => a.avg5 - b.avg5);

      const medianIndex = Math.floor(entries.length / 2);
      const medianWPM = entries.length ? entries[medianIndex]?.avg5 || 0 : 0;
      const maxYValue = Math.max(medianWPM * 2, 100);

      const filteredEntries = entries.filter(entry => entry.avg5 <= maxYValue * 2);

      const allWordsAvg = filteredEntries.length ?
        utils.calculateAverage(filteredEntries.map(e => e.avg5)) : 0;

      const slow10Avg = filteredEntries.length ?
        utils.calculateAverage(
          filteredEntries.slice(0, Math.min(10, filteredEntries.length))
            .map(e => e.avg5)
        ) : 0;

      const dataPoints = filteredEntries.map((entry, index) => ({
        x: index + 1,
        y: entry.avg5,
        originalWord: entry.word
      }));

      const ctx = document.getElementById("wordsScatterChart").getContext("2d");

      if (scatterChart) {
        scatterChart.destroy();
      }

      scatterChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Words by WPM (Slowest to Fastest)',
              data: dataPoints,
              backgroundColor: dataPoints.map((_, index) =>
                index < 10 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 0.5)'
              ),
              pointRadius: 6,
              pointHoverRadius: 8
            },
            {
              label: `Average WPM (All Words): ${utils.formatNumber(allWordsAvg)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: allWordsAvg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 2,
              borderDash: [5, 5]
            },
            {
              label: `Average WPM (10 Slowest Words): ${utils.formatNumber(slow10Avg)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: slow10Avg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(255, 159, 64, 1)',
              borderWidth: 2,
              borderDash: [10, 5]
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Words Ranked by Speed (Slowest to Fastest)'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  if (context.datasetIndex === 0) {
                    return `"${context.raw.originalWord}": ${utils.formatNumber(context.parsed.y)} WPM`;
                  } else if (context.datasetIndex === 1) {
                    return `Average WPM (All Words): ${utils.formatNumber(allWordsAvg)}`;
                  } else {
                    return `Average WPM (10 Slowest Words): ${utils.formatNumber(slow10Avg)}`;
                  }
                }
              }
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                boxWidth: 15,
                padding: 15,
                font: {
                  weight: 'bold'
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Word Rank'
              },
              ticks: {
                stepSize: 1
              }
            },
            y: {
              title: {
                display: true,
                text: 'WPM (Avg Last 5)'
              },
              beginAtZero: true,
              suggestedMax: maxYValue
            }
          }
        }
      });
    }

    // Update theme function to include the scatter chart container
    function toggleTheme() {
      const dark = document.body.classList.toggle("dark");
      localStorage.setItem('theme', dark ? 'dark' : 'light');

      // Update chart containers styling based on theme
      const containers = [
        document.getElementById("performanceChartContainer"),
        document.getElementById("wordsScatterContainer")
      ];

      containers.forEach(container => {
        if (container) {
          if (dark) {
            container.style.backgroundColor = "#1e1e1e";
            container.style.borderColor = "#444";
          } else {
            container.style.backgroundColor = "#f9f9f9";
            container.style.borderColor = "#ccc";
          }
        }
      });
    }

    // Update load theme function for both containers
    function loadTheme() {
      const theme = localStorage.getItem('theme');
      if (theme === "dark") {
        document.body.classList.add("dark");

        const containers = [
          document.getElementById("performanceChartContainer"),
          document.getElementById("wordsScatterContainer")
        ];

        containers.forEach(container => {
          if (container) {
            container.style.backgroundColor = "#1e1e1e";
            container.style.borderColor = "#444";
          }
        });
      }
    }

    function refreshCharts() {
      try {
        renderChart();
        renderWordsScatterChart();
      } catch (err) {
        console.error("Error refreshing charts:", err);
      }
    }

    function renderConfusionMatrix() {
      const matrixDiv = document.getElementById("confusionMatrix");
      const letters = Array.from(new Set(Object.keys(pairTimings).flatMap(pair => pair.split("->")))).sort();

      // Find the max time to normalize the color scale
      let maxTime = 0;
      for (const pair in pairTimings) {
        const last10 = pairTimings[pair].occurrences.slice(-10); // Get the last 10 occurrences
        const avgTime = last10.length ? last10.reduce((a, b) => a + b, 0) / last10.length : 0;
        if (pairTimings[pair].count > 10 && avgTime > maxTime) maxTime = avgTime;
      }

      let html = '<h2>Confusion Matrix (Time Between Letters)</h2><table><tr><th></th>';
      letters.forEach(letter => html += `<th>${letter}</th>`);
      html += '</tr>';

      letters.forEach(rowLetter => {
        html += `<tr><th>${rowLetter}</th>`;
        letters.forEach(colLetter => {
          const pair = `${rowLetter}->${colLetter}`;
          const data = pairTimings[pair];
          const last10 = data ? data.occurrences.slice(-10) : []; // Get the last 10 occurrences
          const avgTime = last10.length ? (last10.reduce((a, b) => a + b, 0) / last10.length).toFixed(1) : "-";
          const count = data ? data.count : 0;

          // Calculate color intensity only if there are more than 10 measurements
          let color = "#fff"; // Default white for no data
          if (data && count > 10 && last10.length) {
            const intensity = avgTime / maxTime; // Normalize between 0 and 1
            const red = Math.min(255, Math.floor(255 * intensity));
            const green = Math.min(255, Math.floor(255 * (1 - intensity)));
            color = `rgb(${red}, ${green}, 0)`;
          }

          html += `<td style="background-color: ${color};">${avgTime} (${count})</td>`;
        });
        html += '</tr>';
      });

      html += '</table>';
      matrixDiv.innerHTML = html;
    }

    loadTheme();

    fetch('https://raw.githubusercontent.com/monkeytypegame/monkeytype/refs/heads/master/frontend/static/languages/english.json')
      .then(res => res.json())
      .then(data => {
        english1k = data.words
        loadStatsFromStorage();
        startTest();
      });

    window.addEventListener("beforeunload", savePairTimings);
  </script>
  <div id="wordTooltip" class="word-tooltip"></div>
</body>

</html>