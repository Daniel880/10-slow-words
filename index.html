<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>10 Slow Words</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #fff;
      color: #000;
    }

    .dark {
      background-color: #121212;
      color: #e0e0e0;
    }

    .word-list {
      margin-bottom: 20px;
      font-size: 3em;
    }

    .word-list span {
      margin-right: 5px;
    }

    .current {
      text-decoration: underline;
    }

    .correct {
      color: green;
    }

    .incorrect {
      color: red;
    }

    input {
      width: 100%;
      font-size: 3em;
      padding: 5px;
    }

    .results,
    .stats {
      margin-top: 20px;
    }

    .highlight {
      font-weight: bold;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f0f0f0;
    }

    .dark th,
    .dark td {
      background-color: #1e1e1e;
      color: #fff;
      border-color: #333;
    }

    .dark th {
      background-color: #2e2e2e;
    }

    .dark input {
      background-color: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
    }

    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
    }

    .global-stats {
      display: flex;
      gap: 2em;
      font-size: 1.2em;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>
  <h1>10 Slow Words</h1>
  <div class="word-list" id="wordList"></div>
  <input type="text" id="input" placeholder="Start typing..." autofocus />
  <div class="results" id="results"></div>
  <div class="stats" id="stats"></div>
  <canvas id="wpmChart" width="800" height="400"></canvas>
  <canvas id="wordsScatterChart" width="800" height="400"></canvas>
  <button onclick="resetStats()">Reset All Stats</button>
  <button onclick="toggleTheme()">Toggle Dark Mode</button>

  <script>
    let english1k = [];
    let testWords = [];
    let startTime = null;
    let testStartTime;
    let currentIndex = 0;
    let wordStats = {};
    let history = [];
    let slowestWords = [];
    let chart;
    let slow10WPMHistory = [];
    let testWPMHistory = [];

    // Add these variables at the top to track sorting
    let currentSortColumn = 'avg5'; // Default sort by Avg Last 5
    let currentSortDirection = 'asc'; // Default ascending order

    function loadStatsFromStorage() {
      const stats = localStorage.getItem('wordStats');
      const historyData = localStorage.getItem('slow10WPMHistory');
      const testHistoryData = localStorage.getItem('testWPMHistory');
      if (stats) {
        try { wordStats = JSON.parse(stats); } catch { }
      }
      if (historyData) {
        try { slow10WPMHistory = JSON.parse(historyData); } catch { }
      }
      if (testHistoryData) {
        try { testWPMHistory = JSON.parse(testHistoryData); } catch { }
      }
    }

    function saveStatsToStorage() {
      localStorage.setItem('wordStats', JSON.stringify(wordStats));
      localStorage.setItem('slow10WPMHistory', JSON.stringify(slow10WPMHistory));
      localStorage.setItem('testWPMHistory', JSON.stringify(testWPMHistory));
    }

    function resetStats() {
      wordStats = {};
      slow10WPMHistory = [];
      testWPMHistory = [];
      saveStatsToStorage();
      startTest();
    }

    function getTestWords() {
      if (Object.keys(wordStats).length === 0) {
        return english1k.sort(() => 0.5 - Math.random()).slice(0, 20);
      }
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      const random = english1k.sort(() => 0.5 - Math.random()).slice(0, 10);
      return [...new Set([...slowestWords, ...random])].slice(0, 20);
    }

    function renderWords() {
      const container = document.getElementById("wordList");
      container.innerHTML = testWords.map((word, i) => {
        let cls = "";
        if (i === currentIndex) cls = "current";
        else if (i < currentIndex) cls = "correct";
        if (slowestWords.includes(word)) cls += " highlight"; // Highlight slowest words
        return `<span class="${cls}">${word}</span>`;
      }).join(" ");
    }

    function renderStats() {
      const statsDiv = document.getElementById("stats");
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : 0;
        return {
          word,
          count: data.count || 0,
          avg5,
          avg: data.avg,
          last: data.last
        };
      });

      // Sort entries based on current sort column and direction
      entries.sort((a, b) => {
        let valueA = a[currentSortColumn];
        let valueB = b[currentSortColumn];

        // Special handling for text column (word)
        if (currentSortColumn === 'word') {
          return currentSortDirection === 'asc'
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);
        }

        // Numerical columns
        return currentSortDirection === 'asc'
          ? valueA - valueB
          : valueB - valueA;
      });

      // Create table with clickable headers
      let html = '<h2>Word Stats</h2><table><tr>';

      // Define column structure for easier maintenance
      const columns = [
        { id: 'index', label: '#', sortable: false },
        { id: 'word', label: 'Word', sortable: true },
        { id: 'count', label: 'Count', sortable: true },
        { id: 'avg5', label: 'Avg Last 5', sortable: true },
        { id: 'avg', label: 'Overall Avg', sortable: true },
        { id: 'last', label: 'Last', sortable: true }
      ];

      // Generate headers
      columns.forEach(column => {
        if (column.sortable) {
          const sortIcon = currentSortColumn === column.id
            ? (currentSortDirection === 'asc' ? '▲' : '▼')
            : '';
          html += `<th data-sort="${column.id}" class="sortable">${column.label} ${sortIcon}</th>`;
        } else {
          html += `<th>${column.label}</th>`;
        }
      });

      html += '</tr>';

      // Generate table rows
      entries.forEach((entry, idx) => {
        const rowClass = idx < 10 ? 'highlight' : '';
        html += `<tr class="${rowClass}">
          <td>${idx + 1}</td>
          <td>${entry.word}</td>
          <td>${entry.count}</td>
          <td>${entry.avg5.toFixed(1)}</td>
          <td>${entry.avg.toFixed(1)}</td>
          <td>${entry.last.toFixed(1)}</td>
        </tr>`;
      });

      html += '</table>';
      statsDiv.innerHTML = html;

      // Add event listeners to sortable headers
      document.querySelectorAll('.sortable').forEach(header => {
        header.addEventListener('click', function () {
          const column = this.getAttribute('data-sort');

          // Toggle direction if same column, otherwise set to asc
          if (column === currentSortColumn) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortColumn = column;
            currentSortDirection = 'asc';
          }

          renderStats();
        });
      });
    }

    function renderChart() {
      // Make sure we have data to show
      if (testWPMHistory.length === 0) return;

      // Calculate rolling average of the overall test WPMs (last 5 tests)
      const avg5Line = [];
      for (let i = 0; i < testWPMHistory.length; i++) {
        const slice = testWPMHistory.slice(Math.max(0, i - 4), i + 1);
        avg5Line.push(slice.reduce((a, b) => a + b, 0) / slice.length);
      }

      const ctx = document.getElementById("wpmChart").getContext("2d");
      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: Array.from({ length: testWPMHistory.length }, (_, i) => i + 1),
          datasets: [
            {
              label: 'Avg WPM of 10 Slowest Words',
              data: slow10WPMHistory,
              borderColor: 'blue',
              backgroundColor: 'blue',
              fill: false,
              tension: 0.3,
              pointRadius: 4
            },
            {
              label: 'Rolling Avg of Overall Tests (last 5)',
              data: avg5Line,
              borderColor: 'orange',
              backgroundColor: 'orange',
              fill: false,
              borderDash: [5, 5],
              tension: 0.3,
              pointRadius: 4
            }
          ]
        },
        options: {
          plugins: {
            title: {
              display: true,
              text: 'WPM Performance Over Time'
            }
          },
          scales: {
            x: { title: { display: true, text: 'Test #' } },
            y: { title: { display: true, text: 'WPM' }, beginAtZero: true }
          }
        }
      });
    }

    function renderWordsScatterChart() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : 0;
        return { word, avg5 };
      });

      // Sort entries by avg5 (slowest to fastest)
      entries.sort((a, b) => a.avg5 - b.avg5);

      // Create data points where X is the index and Y is the WPM
      const dataPoints = entries.map((entry, index) => ({
        x: index + 1,
        y: entry.avg5
      }));

      const ctx = document.getElementById("wordsScatterChart").getContext("2d");
      new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Words by WPM (Slowest to Fastest)',
            data: dataPoints,
            backgroundColor: dataPoints.map((_, index) =>
              index < 10 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 0.5)'
            ),
            pointRadius: 6,
            pointHoverRadius: 8
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Words Ranked by Speed (Slowest to Fastest)'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return `Word #${context.parsed.x}: ${context.parsed.y.toFixed(1)} WPM`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Word Rank'
              },
              ticks: {
                stepSize: 1
              }
            },
            y: {
              title: {
                display: true,
                text: 'WPM (Avg Last 5)'
              },
              beginAtZero: true
            }
          }
        }
      });
    }

    function startTest() {
      testWords = getTestWords();
      currentIndex = 0;
      testStartTime = null;
      startTime = null;
      document.getElementById("input").value = "";
      history = [];
      renderWords();
      renderStats();
      renderChart();
      renderWordsScatterChart();
      document.getElementById("input").focus();
    }

    function handleCorrectWord(word) {
      const now = performance.now();
      const duration = (now - startTime) / 1000 / 60;
      const wpm = 1 / duration;

      if (!wordStats[word]) {
        wordStats[word] = {
          avg: wpm,
          last: wpm,
          last5: [wpm],
          count: 1  // Initialize count to 1 for new words
        };
      } else {
        wordStats[word].avg = (wordStats[word].avg * 0.8 + wpm * 0.2);
        wordStats[word].last = wpm;
        wordStats[word].last5 = (wordStats[word].last5 || []).slice(-4).concat(wpm);
        wordStats[word].count = (wordStats[word].count || 0) + 1; // Increment count
      }

      // Update slowestWords list immediately after each word is typed
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      saveStatsToStorage();
      history.push({ word, wpm });
      currentIndex++;
      startTime = now;
    }

    function showResults() {
      // Calculate the average WPM of the 10 slowest words
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? last5.reduce((a, b) => a + b, 0) / last5.length : Infinity;
        return { word, avg5 };
      });
      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? (slow10.map(e => e.avg5).reduce((a, b) => a + b, 0) / slow10.length) : 0;

      // Save the average WPM of 10 slowest words for the chart
      if (!isNaN(avgOf10)) {
        slow10WPMHistory.push(parseFloat(avgOf10.toFixed(1)));
      }

      // Calculate overall WPM for the whole test
      const totalTimeMin = (performance.now() - testStartTime) / 1000 / 60;
      const overallWPM = testWords.length / totalTimeMin;

      // Save the overall WPM for the chart
      testWPMHistory.push(parseFloat(overallWPM.toFixed(1)));

      // Calculate average of all overall test WPMs
      const avgTestWPM = testWPMHistory.length
        ? (testWPMHistory.reduce((a, b) => a + b, 0) / testWPMHistory.length).toFixed(1)
        : "-";

      saveStatsToStorage();

      // Display the three metrics under the test
      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = `
        <h2>Results</h2>
        <div class="global-stats">
          <div><strong>Last Test WPM:</strong> ${overallWPM.toFixed(1)}</div>
          <div><strong>Average WPM:</strong> ${avgTestWPM}</div>
          <div><strong>Slowest 10 Words WPM:</strong> ${avgOf10.toFixed(1)}</div>
        </div>
      `;

      renderChart();
      renderWordsScatterChart();
    }

    document.getElementById("input").addEventListener("input", function () {
      const typed = this.value.trim();
      const expected = testWords[currentIndex];
      if (!testStartTime && typed.length > 0) {
        testStartTime = performance.now();
        startTime = testStartTime;
      }

      const currentWordEl = document.querySelector(".current");
      if (expected.startsWith(typed)) {
        currentWordEl.classList.remove("incorrect");
      } else {
        currentWordEl.classList.add("incorrect");
      }

      if (typed === expected && currentIndex === testWords.length - 1) {
        handleCorrectWord(expected);
        showResults();
        startTest();
      }
    });

    document.getElementById("input").addEventListener("keydown", function (e) {
      if (e.key === " ") {
        e.preventDefault();
        const word = this.value.trim();
        const expected = testWords[currentIndex];
        if (word !== expected || currentIndex === testWords.length - 1) return;
        handleCorrectWord(expected);
        this.value = "";
        renderWords();
        renderStats();
      } else if (e.key === "Escape" || e.key === "Tab") {
        e.preventDefault();
        startTest();
      }
    });

    function toggleTheme() {
      const dark = document.body.classList.toggle("dark");
      localStorage.setItem('theme', dark ? 'dark' : 'light');
    }

    function loadTheme() {
      const theme = localStorage.getItem('theme');
      if (theme === "dark") {
        document.body.classList.add("dark");
      }
    }

    loadTheme();

    fetch('https://raw.githubusercontent.com/SMenigat/thousand-most-common-words/master/words/en.json')
      .then(res => res.json())
      .then(data => {
        // Clean up apostrophes in words
        english1k = data.words
          .map(w => w.englishWord)
          .filter(w => w)
          .map(word => word.replace(/[''′`´]/g, "'"));

        loadStatsFromStorage();
        startTest();
      });
  </script>
</body>

</html>
