<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>10 Slow Words</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #fff;
      color: #000;
    }

    .dark {
      background-color: #121212;
      color: #e0e0e0;
    }

    .word-list {
      margin-bottom: 20px;
      font-size: 3em;
    }

    .word-list span {
      margin-right: 5px;
    }

    .current {
      text-decoration: underline;
    }

    .correct {
      color: green;
    }

    .incorrect {
      color: red;
    }

    input {
      width: 100%;
      font-size: 3em;
      padding: 5px;
    }

    .results,
    .stats {
      margin-top: 20px;
    }

    .highlight {
      font-weight: bold;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f0f0f0;
    }

    .dark th,
    .dark td {
      background-color: #1e1e1e;
      color: #fff;
      border-color: #333;
    }

    .dark th {
      background-color: #2e2e2e;
    }

    .dark input {
      background-color: #1e1e1e;
      color: #fff;
      border: 1px solid #444;
    }

    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 1em;
    }

    .global-stats {
      display: flex;
      gap: 2em;
      font-size: 1.2em;
      margin-bottom: 10px;
    }

    .word-tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      display: none;
      width: 1100px;
      /* Fixed width instead of max-width */
      height: 450px;
      /* Fixed height instead of max-height */
      overflow: visible;
    }

    .dark .word-tooltip {
      background: #222;
      border-color: #444;
      color: #fff;
    }

    .tooltip-canvas {
      width: 100% !important;
      /* Force width with !important */
      height: 400px !important;
      /* Force height with !important */
      display: block;
    }

    .word-cell {
      cursor: pointer;
      text-decoration: underline dotted;
    }

    /* Ensure table cells are square */
    #confusionMatrix table {
      table-layout: fixed;
    }

    #confusionMatrix th,
    #confusionMatrix td {
      width: 10px;
      /* Set a fixed width */
      height: 10px;
      /* Set a fixed height */
      text-align: center;
      /* Center text */
      vertical-align: middle;
      /* Center text vertically */
    }
  </style>
</head>

<body>
  <h1>10 Slow Words</h1>
  <div class="word-list" id="wordList"></div>
  <input type="text" id="input" placeholder="Start typing..." autofocus />
  <div class="results" id="results"></div>
  <div class="stats" id="stats"></div>
  <canvas id="wpmChart" width="800" height="400"></canvas>
  <canvas id="wordsScatterChart" width="800" height="400"></canvas>
  <button onclick="resetStats()">Reset All Stats</button>
  <button onclick="toggleTheme()">Toggle Dark Mode</button>
  <button onclick="refreshCharts()">Refresh Charts</button>
  <button onclick="renderConfusionMatrix()">Show Confusion Matrix</button>
  <div id="confusionMatrix"></div>
  <div id="confusionMatrix"></div>

  <script>
    let english1k = [];
    let testWords = [];
    let startTime = null;
    let testStartTime;
    let currentIndex = 0;
    let wordStats = {};
    let history = [];
    let slowestWords = [];
    let chart;
    let scatterChart;
    let slow10WPMHistory = [];
    let testWPMHistory = [];
    let wordStartTime = null;
    let currentSortColumn = 'avg5';
    let currentSortDirection = 'asc';

    let lastKey = null; // Tracks the last key pressed
    let lastKeyTime = null; // Tracks the timestamp of the last key press

    // Load pair timings from localStorage
    let pairTimings = loadFromLocalStorage("pairTimings") || {};

    // Save pair timings to localStorage
    function savePairTimings() {
      saveToLocalStorage("pairTimings", pairTimings);
    }

    // Utility functions for repeated calculations
    const utils = {
      calculateAverage: (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0,
      formatNumber: (num, decimals = 1) => Number.isFinite(num) ? num.toFixed(decimals) : "-",
      getColorScheme: () => document.body.classList.contains('dark') ?
        { primary: 'rgb(75, 192, 255)', primaryAlpha: 'rgba(75, 192, 255, 0.2)' } :
        { primary: 'rgb(75, 192, 192)', primaryAlpha: 'rgba(75, 192, 192, 0.2)' }
    };

    // Utility functions for localStorage
    function saveToLocalStorage(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    function loadFromLocalStorage(key) {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }

    // Add a helper function to store all history for each word
    function updateWordStats(word, wpm) {
      if (!wordStats[word]) {
        wordStats[word] = {
          avg: wpm,
          last: wpm,
          last5: [wpm],
          allHistory: [wpm], // New array to store all attempts
          count: 1
        };
      } else {
        wordStats[word].avg = (wordStats[word].avg * 0.8 + wpm * 0.2);
        wordStats[word].last = wpm;
        wordStats[word].last5 = (wordStats[word].last5 || []).slice(-4).concat(wpm);
        // Add to the full history array
        if (!wordStats[word].allHistory) wordStats[word].allHistory = [];
        wordStats[word].allHistory.push(wpm);
        wordStats[word].count = (wordStats[word].count || 0) + 1;
      }
    }

    function updateResultsDisplay() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
        return { word, avg5 };
      });

      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? utils.calculateAverage(slow10.map(e => e.avg5)) : 0;

      const avgTestWPM = testWPMHistory.length
        ? utils.formatNumber(utils.calculateAverage(testWPMHistory))
        : "-";

      const lastTestWPM = testWPMHistory.length
        ? utils.formatNumber(testWPMHistory[testWPMHistory.length - 1])
        : "-";

      const resultsDiv = document.getElementById("results");
      resultsDiv.innerHTML = `
        <h2>Statistics</h2>
        <div class="global-stats">
          <div><strong>Last Test WPM:</strong> ${lastTestWPM}</div>
          <div><strong>Average WPM:</strong> ${avgTestWPM}</div>
          <div><strong>Slowest 10 Words WPM:</strong> ${utils.formatNumber(avgOf10)}</div>
        </div>
      `;
    }

    // Update the chart generation function to use full history
    function generateWordProgressChart(word) {
      const data = wordStats[word];
      console.log('Generating chart for:', word, data);

      if (!data) {
        console.log('No data for word:', word);
        return false;
      }

      // Use all history if available, otherwise fall back to last5
      const chartData = data.allHistory || data.last5;

      if (!chartData || chartData.length === 0) {
        console.log('No chart data available for word:', word);
        return false;
      }

      const tooltipDiv = document.getElementById('wordTooltip');
      if (!tooltipDiv) {
        console.error('Tooltip div not found!');
        return false;
      }

      tooltipDiv.innerHTML = `
        <p>Progress for word "${word}" (${chartData.length} attempts)</p>
        <canvas id="tooltipChart" class="tooltip-canvas"></canvas>
      `;

      const canvas = document.getElementById('tooltipChart');
      if (!canvas) {
        console.error('Chart canvas element not found!');
        return false;
      }

      const ctx = canvas.getContext('2d');

      if (window.tooltipChart && typeof window.tooltipChart.destroy === 'function') {
        window.tooltipChart.destroy();
      }

      const labels = chartData.map((_, i) => `Attempt #${i + 1}`);
      const avgWPM = utils.calculateAverage(chartData);
      const colors = utils.getColorScheme();

      // Calculate trend line values
      const trendValues = [];
      if (chartData.length > 1) {
        // Simple linear regression
        const xValues = Array.from({ length: chartData.length }, (_, i) => i + 1);
        const xMean = utils.calculateAverage(xValues);
        const yMean = avgWPM;

        let numerator = 0;
        let denominator = 0;

        for (let i = 0; i < chartData.length; i++) {
          numerator += (xValues[i] - xMean) * (chartData[i] - yMean);
          denominator += Math.pow(xValues[i] - xMean, 2);
        }

        const slope = denominator ? numerator / denominator : 0;
        const intercept = yMean - (slope * xMean);

        // Generate the trend line data points
        for (let i = 0; i < chartData.length; i++) {
          trendValues.push(slope * (i + 1) + intercept);
        }
      }

      // Get first and last values for displaying improvement
      let improvement = "";
      if (chartData.length > 1) {
        const first = chartData[0];
        const last = chartData[chartData.length - 1];
        const changePercent = ((last - first) / first * 100).toFixed(1);
        improvement = ` (${changePercent > 0 ? '+' : ''}${changePercent}% from first attempt)`;
      }

      window.tooltipChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'WPM',
              data: chartData,
              borderColor: colors.primary,
              backgroundColor: colors.primaryAlpha,
              fill: true,
              tension: 0.3
            },
            // Add trend line if we have more than one data point
            ...(chartData.length > 1 ? [{
              label: 'Trend',
              data: trendValues,
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 2,
              borderDash: [5, 5],
              fill: false,
              pointRadius: 0
            }] : [])
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              left: 20,
              right: 30,
              top: 30,
              bottom: 20
            }
          },
          plugins: {
            title: {
              display: true,
              text: `Progress for "${word}" (Avg: ${utils.formatNumber(avgWPM)} WPM)${improvement}`,
              font: {
                size: 18
              }
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return `WPM: ${utils.formatNumber(context.parsed.y)}`;
                }
              }
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: 'WPM',
                font: {
                  size: 14
                }
              },
              suggestedMin: Math.max(0, avgWPM * 0.5),
              suggestedMax: avgWPM * 1.5
            },
            x: {
              title: {
                display: true,
                text: 'Attempts',
                font: {
                  size: 14
                }
              }
            }
          }
        }
      });

      return true;
    }

    // Keep the same event handler implementations from your original code
    document.getElementById("input").addEventListener("input", function (e) {
      const typed = this.value.trim();
      const currentTime = performance.now();
      const expected = testWords[currentIndex];

      // Check for incorrect input
      const wordListSpans = document.querySelectorAll("#wordList span");
      if (expected && !expected.startsWith(typed)) {
        wordListSpans[currentIndex].classList.add("incorrect");
      } else {
        wordListSpans[currentIndex].classList.remove("incorrect");
      }

      // Only record transitions if the typed input matches the expected word so far
      if (expected && expected.startsWith(typed) && lastKey && lastKeyTime) {
        const timeDiff = currentTime - lastKeyTime;

        // Ignore outliers with time differences greater than 2 seconds
        if (timeDiff <= 5000) {
          const pair = `${lastKey}->${typed[typed.length - 1]}`;

          if (!pairTimings[pair]) {
            pairTimings[pair] = { total: 0, count: 0, occurrences: [] };
          }

          pairTimings[pair].total += timeDiff;
          pairTimings[pair].count += 1;
          pairTimings[pair].occurrences.push(timeDiff);

          // Save updated pair timings to localStorage
          savePairTimings();
        }
      }

      lastKey = typed[typed.length - 1];
      lastKeyTime = currentTime;
    });

    document.getElementById("input").addEventListener("keydown", function (e) {
      if (e.key === " ") {
        e.preventDefault();
        const word = this.value.trim();
        const expected = testWords[currentIndex];

        if (!expected || word !== expected) return;

        handleCorrectWord(expected);
        this.value = "";

        if (currentIndex === testWords.length) {
          showResults();
          startTest(); // Reload the test after showing results
        } else {
          renderWords();
        }
      } else if (!wordStartTime &&
        !e.key.startsWith('Shift') &&
        !e.key.startsWith('Control') &&
        !e.key.startsWith('Alt') &&
        !e.key.startsWith('Meta') &&
        !e.key.startsWith('Arrow') &&
        !e.key.startsWith('Tab') &&
        !e.key.startsWith('Caps') &&
        !e.key.startsWith('Escape') &&
        !e.key.startsWith('F') &&
        e.key.length === 1) {
        wordStartTime = performance.now();
      }
    });

    // Keep all your original functionality but make the code more maintainable
    function handleCorrectWord(word) {
      const now = performance.now();

      if (!wordStartTime) return;

      const duration = (now - wordStartTime) / 1000 / 60;
      wordStartTime = null;

      const wordLetterCount = word.length + 1;
      const wpm = (wordLetterCount / 5) / duration;

      // Update stats for the word
      updateWordStats(word, wpm);

      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      saveStatsToStorage();
      history.push({ word, wpm });
      currentIndex++;

      // Check if the test is finished
      if (currentIndex >= testWords.length) {
        showResults();
      } else {
        renderWords();
      }

      // Re-render the stats table after each word
      renderStats();
    }

    function showResults() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
        return { word, avg5 };
      });

      const slow10 = entries.sort((a, b) => a.avg5 - b.avg5).slice(0, 10);
      const avgOf10 = slow10.length ? utils.calculateAverage(slow10.map(e => e.avg5)) : 0;

      if (!isNaN(avgOf10)) {
        slow10WPMHistory.push(parseFloat(avgOf10.toFixed(1)));
      }

      const totalCharCount = testWords.reduce((sum, word) => sum + word.length, 0);
      const spacesCount = testWords.length - 1;
      const totalTimeMin = (performance.now() - testStartTime) / 1000 / 60;
      const overallWPM = ((totalCharCount + spacesCount) / 5) / totalTimeMin;

      testWPMHistory.push(parseFloat(overallWPM.toFixed(1)));

      saveStatsToStorage();
      updateResultsDisplay();
      renderChart();
      renderWordsScatterChart();
    }

    // Maintain all the other functions with small improvements
    function startTest() {
      testWords = getTestWords();
      currentIndex = 0;
      testStartTime = null;
      startTime = null;
      document.getElementById("input").value = "";
      history = [];
      renderWords();
      renderStats();
      renderChart();
      renderWordsScatterChart();
      updateResultsDisplay();
      document.getElementById("input").focus();

      // Remove the "TEST" word initialization
      if (Object.keys(wordStats).length === 0) {
        wordStats = {}; // Ensure stats are empty if no prior data exists
      }
    }

    function loadStatsFromStorage() {
      const stats = localStorage.getItem('wordStats');
      const historyData = localStorage.getItem('slow10WPMHistory');
      const testHistoryData = localStorage.getItem('testWPMHistory');
      if (stats) {
        try { wordStats = JSON.parse(stats); } catch { }
      }
      if (historyData) {
        try { slow10WPMHistory = JSON.parse(historyData); } catch { }
      }
      if (testHistoryData) {
        try { testWPMHistory = JSON.parse(testHistoryData); } catch { }
      }
      updateResultsDisplay();
    }

    function saveStatsToStorage() {
      localStorage.setItem('wordStats', JSON.stringify(wordStats));
      localStorage.setItem('slow10WPMHistory', JSON.stringify(slow10WPMHistory));
      localStorage.setItem('testWPMHistory', JSON.stringify(testWPMHistory));
    }

    function resetStats() {
      wordStats = {};
      slow10WPMHistory = [];
      testWPMHistory = [];
      pairTimings = {};
      saveStatsToStorage();
      startTest();
    }

    function getTestWords() {
      if (Object.keys(wordStats).length === 0) {
        return english1k.sort(() => 0.5 - Math.random()).slice(0, 20);
      }
      slowestWords = Object.entries(wordStats)
        .map(([word, stats]) => {
          const last5 = stats.last5 || [];
          const avg5 = last5.length ? utils.calculateAverage(last5) : Infinity;
          return { word, avg5 };
        })
        .sort((a, b) => a.avg5 - b.avg5)
        .slice(0, 10)
        .map(e => e.word);

      const random = english1k.sort(() => 0.5 - Math.random()).slice(0, 10);
      return [...new Set([...slowestWords, ...random])].slice(0, 20);
    }

    function renderWords() {
      const container = document.getElementById("wordList");
      container.innerHTML = testWords.map((word, i) => {
        let cls = "";
        if (i === currentIndex) cls = "current";
        else if (i < currentIndex) cls = "correct";
        if (slowestWords.includes(word)) cls += " highlight";
        return `<span class="${cls}">${word}</span>`;
      }).join(" ");
    }

    function renderStats() {
      const statsDiv = document.getElementById("stats");
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : 0;
        return {
          word,
          count: data.count || 0,
          avg5,
          avg: data.avg,
          last: data.last
        };
      });

      entries.sort((a, b) => {
        let valueA = a[currentSortColumn];
        let valueB = b[currentSortColumn];

        if (currentSortColumn === 'word') {
          return currentSortDirection === 'asc'
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);
        }

        return currentSortDirection === 'asc'
          ? valueA - valueB
          : valueB - valueA;
      });

      let html = '<h2>Word Stats</h2><table><tr>';

      const columns = [
        { id: 'index', label: '#', sortable: false },
        { id: 'word', label: 'Word', sortable: true },
        { id: 'count', label: 'Count', sortable: true },
        { id: 'avg5', label: 'Avg Last 5', sortable: true },
        { id: 'avg', label: 'Overall Avg', sortable: true },
        { id: 'last', label: 'Last', sortable: true }
      ];

      columns.forEach(column => {
        if (column.sortable) {
          const sortIcon = currentSortColumn === column.id
            ? (currentSortDirection === 'asc' ? '▲' : '▼')
            : '';
          html += `<th data-sort="${column.id}" class="sortable">${column.label} ${sortIcon}</th>`;
        } else {
          html += `<th>${column.label}</th>`;
        }
      });

      html += '</tr>';

      entries.forEach((entry, idx) => {
        const rowClass = idx < 10 ? 'highlight' : '';
        html += `<tr class="${rowClass}">
          <td>${idx + 1}</td>
          <td class="word-cell" data-word="${entry.word}">${entry.word}</td>
          <td>${entry.count}</td>
          <td>${utils.formatNumber(entry.avg5)}</td>
          <td>${utils.formatNumber(entry.avg)}</td>
          <td>${utils.formatNumber(entry.last)}</td>
        </tr>`;
      });

      html += '</table>';
      statsDiv.innerHTML = html;

      document.querySelectorAll('.sortable').forEach(header => {
        header.addEventListener('click', function () {
          const column = this.getAttribute('data-sort');

          if (column === currentSortColumn) {
            currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortColumn = column;
            currentSortDirection = 'asc';
          }

          renderStats();
        });
      });

      const tooltipDiv = document.getElementById("wordTooltip");
      if (!tooltipDiv) {
        console.error("Tooltip div not found!");
        return;
      }

      document.querySelectorAll('.word-cell').forEach(cell => {
        const word = cell.getAttribute('data-word');

        cell.addEventListener('mouseenter', (e) => {
          console.log('Mouse entered cell for word:', word);
          const result = generateWordProgressChart(word);
          if (result) {
            tooltipDiv.style.display = 'block';
            tooltipDiv.style.left = `${e.pageX + 15}px`;
            tooltipDiv.style.top = `${e.pageY + 15}px`;
          } else {
            console.log('No chart data available for word:', word);
          }
        });

        cell.addEventListener('mouseleave', () => {
          tooltipDiv.style.display = 'none';
        });

        cell.addEventListener('mousemove', (e) => {
          tooltipDiv.style.left = `${e.pageX + 15}px`;
          tooltipDiv.style.top = `${e.pageY + 15}px`;
        });
      });
    }

    function renderChart() {
      if (testWPMHistory.length === 0) return;

      const avg5Line = [];
      for (let i = 0; i < testWPMHistory.length; i++) {
        const slice = testWPMHistory.slice(Math.max(0, i - 4), i + 1);
        avg5Line.push(utils.calculateAverage(slice));
      }

      const lastSlow10Avg = slow10WPMHistory.length > 0 ?
        utils.formatNumber(slow10WPMHistory[slow10WPMHistory.length - 1]) : "0.0";
      const lastAvg5 = avg5Line.length > 0 ?
        utils.formatNumber(avg5Line[avg5Line.length - 1]) : "0.0";

      const ctx = document.getElementById("wpmChart").getContext("2d");
      try {
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: Array.from({ length: testWPMHistory.length }, (_, i) => i + 1),
            datasets: [
              {
                label: `Avg WPM of 10 Slowest Words: ${lastSlow10Avg} WPM`,
                data: slow10WPMHistory,
                borderColor: 'blue',
                backgroundColor: 'blue',
                fill: false,
                tension: 0.3,
                pointRadius: 4
              },
              {
                label: `Rolling Avg of Overall Tests: ${lastAvg5} WPM`,
                data: avg5Line,
                borderColor: 'orange',
                backgroundColor: 'orange',
                fill: false,
                borderDash: [5, 5],
                tension: 0.3,
                pointRadius: 4
              }
            ]
          },
          options: {
            plugins: {
              title: {
                display: true,
                text: 'WPM Performance Over Time'
              },
              legend: {
                display: true,
                position: 'top',
                labels: {
                  boxWidth: 15,
                  padding: 15,
                  font: {
                    weight: 'bold'
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Test #' } },
              y: { title: { display: true, text: 'WPM' }, beginAtZero: true }
            }
          }
        });
      } catch (err) {
        console.error("Error rendering chart:", err);
      }
    }

    function renderWordsScatterChart() {
      const entries = Object.entries(wordStats).map(([word, data]) => {
        const last5 = data.last5 || [];
        const avg5 = last5.length ? utils.calculateAverage(last5) : 0;
        return { word, avg5 };
      });

      entries.sort((a, b) => a.avg5 - b.avg5);

      const medianIndex = Math.floor(entries.length / 2);
      const medianWPM = entries.length ? entries[medianIndex]?.avg5 || 0 : 0;
      const maxYValue = Math.max(medianWPM * 2, 100);

      const filteredEntries = entries.filter(entry => entry.avg5 <= maxYValue * 2);

      const allWordsAvg = filteredEntries.length ?
        utils.calculateAverage(filteredEntries.map(e => e.avg5)) : 0;

      const slow10Avg = filteredEntries.length ?
        utils.calculateAverage(
          filteredEntries.slice(0, Math.min(10, filteredEntries.length))
            .map(e => e.avg5)
        ) : 0;

      const dataPoints = filteredEntries.map((entry, index) => ({
        x: index + 1,
        y: entry.avg5,
        originalWord: entry.word
      }));

      const ctx = document.getElementById("wordsScatterChart").getContext("2d");

      if (scatterChart) {
        scatterChart.destroy();
      }

      scatterChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Words by WPM (Slowest to Fastest)',
              data: dataPoints,
              backgroundColor: dataPoints.map((_, index) =>
                index < 10 ? 'rgba(255, 99, 132, 1)' : 'rgba(54, 162, 235, 0.5)'
              ),
              pointRadius: 6,
              pointHoverRadius: 8
            },
            {
              label: `Average WPM (All Words): ${utils.formatNumber(allWordsAvg)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: allWordsAvg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 2,
              borderDash: [5, 5]
            },
            {
              label: `Average WPM (10 Slowest Words): ${utils.formatNumber(slow10Avg)} WPM`,
              data: Array(dataPoints.length).fill().map((_, i) => ({
                x: i + 1,
                y: slow10Avg
              })),
              showLine: true,
              fill: false,
              pointRadius: 0,
              borderColor: 'rgba(255, 159, 64, 1)',
              borderWidth: 2,
              borderDash: [10, 5]
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Words Ranked by Speed (Slowest to Fastest)'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  if (context.datasetIndex === 0) {
                    return `"${context.raw.originalWord}": ${utils.formatNumber(context.parsed.y)} WPM`;
                  } else if (context.datasetIndex === 1) {
                    return `Average WPM (All Words): ${utils.formatNumber(allWordsAvg)}`;
                  } else {
                    return `Average WPM (10 Slowest Words): ${utils.formatNumber(slow10Avg)}`;
                  }
                }
              }
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                boxWidth: 15,
                padding: 15,
                font: {
                  weight: 'bold'
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Word Rank'
              },
              ticks: {
                stepSize: 1
              }
            },
            y: {
              title: {
                display: true,
                text: 'WPM (Avg Last 5)'
              },
              beginAtZero: true,
              suggestedMax: maxYValue
            }
          }
        }
      });
    }

    function toggleTheme() {
      const dark = document.body.classList.toggle("dark");
      localStorage.setItem('theme', dark ? 'dark' : 'light');
    }

    function loadTheme() {
      const theme = localStorage.getItem('theme');
      if (theme === "dark") {
        document.body.classList.add("dark");
      }
    }

    function refreshCharts() {
      try {
        renderChart();
        renderWordsScatterChart();
      } catch (err) {
        console.error("Error refreshing charts:", err);
      }
    }

    function renderConfusionMatrix() {
      const matrixDiv = document.getElementById("confusionMatrix");
      const letters = Array.from(new Set(Object.keys(pairTimings).flatMap(pair => pair.split("->")))).sort();

      // Find the max time to normalize the color scale
      let maxTime = 0;
      for (const pair in pairTimings) {
        const last10 = pairTimings[pair].occurrences.slice(-10); // Get the last 10 occurrences
        const avgTime = last10.length ? last10.reduce((a, b) => a + b, 0) / last10.length : 0;
        if (pairTimings[pair].count > 10 && avgTime > maxTime) maxTime = avgTime;
      }

      let html = '<h2>Confusion Matrix (Time Between Letters)</h2><table><tr><th></th>';
      letters.forEach(letter => html += `<th>${letter}</th>`);
      html += '</tr>';

      letters.forEach(rowLetter => {
        html += `<tr><th>${rowLetter}</th>`;
        letters.forEach(colLetter => {
          const pair = `${rowLetter}->${colLetter}`;
          const data = pairTimings[pair];
          const last10 = data ? data.occurrences.slice(-10) : []; // Get the last 10 occurrences
          const avgTime = last10.length ? (last10.reduce((a, b) => a + b, 0) / last10.length).toFixed(1) : "-";
          const count = data ? data.count : 0;

          // Calculate color intensity only if there are more than 10 measurements
          let color = "#fff"; // Default white for no data
          if (data && count > 10 && last10.length) {
            const intensity = avgTime / maxTime; // Normalize between 0 and 1
            const red = Math.min(255, Math.floor(255 * intensity));
            const green = Math.min(255, Math.floor(255 * (1 - intensity)));
            color = `rgb(${red}, ${green}, 0)`;
          }

          html += `<td style="background-color: ${color};">${avgTime} (${count})</td>`;
        });
        html += '</tr>';
      });

      html += '</table>';
      matrixDiv.innerHTML = html;
    }

    loadTheme();

    fetch('https://raw.githubusercontent.com/SMenigat/thousand-most-common-words/master/words/en.json')
      .then(res => res.json())
      .then(data => {
        english1k = data.words
          .map(w => w.englishWord)
          .filter(w => w)
          .map(word => word.replace(/'/g, "'"));
        loadStatsFromStorage();
        startTest();
      });

    window.addEventListener("beforeunload", savePairTimings);
  </script>
  <div id="wordTooltip" class="word-tooltip"></div>
</body>

</html>